{
  "name": "ti-commonjs",
  "version": "0.0.1",
  "description": "Node.js style require() in Titanium via Alloy",
  "bugs": {
    "url": "https://github.com/tonylukasavage/ti-commonjs/issues",
    "email": "anthony.lukasavage@gmail.com"
  },
  "author": {
    "name": "Tony Lukasavage",
    "email": "anthony.lukasavage@gmail.com",
    "url": "http://tonylukasavage.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tonylukasavage/ti-commonjs.git"
  },
  "main": "./lib/ti-commonjs.js",
  "engines": {
    "node": ">=0.10"
  },
  "license": "MIT",
  "scripts": {
    "test": "grunt",
    "install": "node ./scripts/install.js"
  },
  "keywords": [
    "titanium",
    "appcelerator",
    "alloy",
    "nodejs",
    "commonjs"
  ],
  "devDependencies": {
    "grunt": "~0.4.2",
    "grunt-contrib-jshint": "~0.8.0",
    "grunt-contrib-clean": "~0.5.0",
    "wrench": "~1.5.8",
    "grunt-titanium": "~0.1.0",
    "grunt-alloy": "~0.1.0",
    "should": "~3.2.0-beta1"
  },
  "readme": "# ti-commonjs [![Appcelerator Titanium](http://www-static.appcelerator.com/badges/alloy-git-badge-sq.png)](http://www.appcelerator.com/titanium/alloy/) [![Built with Grunt](https://cdn.gruntjs.com/builtwith.png)](http://gruntjs.com/) [![Gittip](http://img.shields.io/gittip/Tony%20Lukasavage.png)](https://www.gittip.com/Tony%20Lukasavage/)\n\nNode.js-style CommonJS in Appcelerator Titanium via Alloy. For full details on what exactly this means, check out Node.js's own [documentation on its CommonJS implementation](http://nodejs.org/api/modules.html). In addition to this added functionality, `ti-commonjs` also eliminates _all_ platform-specific disparities in Titanium's CommonJS implementation.\n\n## Requirements\n\n* [Titanium SDK 3.0+](http://www.appcelerator.com/titanium/titanium-sdk/)\n* Alloy 1.3+ âžœ `npm install -g alloy`\n\nIt is distinctly possible that `ti-commonjs` will work with earlier versions of both Titanim and Alloy, but they are untested and unsupported.\n\n## Install [![NPM version](https://badge.fury.io/js/ti-commonjs.png)](http://badge.fury.io/js/ti-commonjs)\n\nAssuming you're in your Alloy project's root folder (not the `app` folder):\n\n```bash\nnpm install ti-commonjs --prefix ./app/lib\n```\n\nAside from installing `ti-commonjs`, this will also add the `alloy.jmk` file (or modifications to existing alloy.jmk) necessary to post-process your generated runtime files. Read [here](http://docs.appcelerator.com/titanium/latest/#!/guide/Build_Configuration_File_(alloy.jmk)) for more details on alloy.jmk files.\n\n## Usage\n\n### absolute paths (relative to \"Resources\" folder)\n\n```javascript\nrequire('/foo/bar');\n```\n\n### relative paths\n\n```javascript\nrequire('../../someModule');\nrequire('./someModuleInCurrentFolder');\nrequire('.././some/ridiculous/../../path');\n```\n\n### loading from `node_modules` folder\n\nLoad modules installed via npm in `Resources/node_modules`. Full details [here](http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders).\n\n```javascript\nvar _ = require('underscore');\nrequire('ti-mocha');\n```\n\nYou can also target specific files within those npm installations. For example, let's take [should.js](https://github.com/visionmedia/should.js/). While you can't require it directly in Titanium, due to its reliance on node.js libraries, you can reference the single-file Titanium-compatible version embedded in the installation. This tactic works with almost every npm distributed module that has a browser-compatible version.\n\n```js\nvar should = require('should'); // ERROR - missing node.js libraries\n\nvar should = require('should/should'); // WOOHOO! It works in Titanium.\n```\n\n### folders as modules\n\nIf a folder contains a `package.json`, the path in its `main` property will be loaded as a module. Additionally, a module named `index.js` can be referenced just by its folder's name. The following example demonstrates both uses. Full details [here](http://nodejs.org/api/modules.html#modules_folders_as_modules).\n\n#### /foo/package.json\n```json\n{\n\t\"main\": \"./lib/quux\"\n}\n```\n\n#### /app.js\n```javascript\n// assuming the module \"Resources/foo/lib/quux.js\" exists...\nvar foo = require('/foo');\n\n// assuming the module \"Resources/bar/index.js\" exists...\nvar bar = require('/bar');\n```\n\n### loading JSON files\n\nYou can now load JSON files simply with `require()`.\n\n```js\nconsole.log(require('/package.json').main);\n\n// prints \"./lib/ti-commonjs.js\"\n```\n\n### require.resolve()\n\nGet the full path resolved path to a module.\n\n```js\nrequire.resolve('/foo/bar.js') === require.resolve('/.././foo/../foo/bar');\n```\n\n### require.main\n\nEvery require function now has a reference to the main module (app.js). Full details [here](http://nodejs.org/api/modules.html#modules_accessing_the_main_module).\n\n#### /foo/bar.js\n```js\nrequire.main.id === '.' && require.main.filename === '/app.js'\n```\n\n### load module with or without extensions\n\n```js\nrequire('/foo') === require('/foo.js')\n```\n\n### \"module\" object\n\nTitanium's implementation gives limited access to the properties of the `module` object. With `ti-commonjs.js` you have full access to the following properties and functions. Full details [here](http://nodejs.org/api/modules.html#modules_the_module_object).\n\n* [module.exports](http://nodejs.org/api/modules.html#modules_module_exports)\n* [exports](http://nodejs.org/api/modules.html#modules_exports_alias)\n* [module.require(id)](http://nodejs.org/api/modules.html#modules_module_require_id)\n* [module.id](http://nodejs.org/api/modules.html#modules_module_id)\n* [module.filename](http://nodejs.org/api/modules.html#modules_module_filename)\n* [module.loaded](http://nodejs.org/api/modules.html#modules_module_loaded)\n* [module.parent](http://nodejs.org/api/modules.html#modules_module_parent) (_not yet implemented_)\n* [module.children](http://nodejs.org/api/modules.html#modules_module_children) (_not yet implemented_)\n\n### Use the Titanium require()\n\nJust in case you still need to use the old `require()` from Titanium, it's still accessible via `tirequire()`.\n\n```js\nrequire('/foo') === tirequire('foo')\n```\n\n## FAQ\n\n* [Why is this so cool?](#why-is-this-so-cool)\n* [Should I use ti-commonjs.js?](#should-i-use-ti-commonjsjs)\n* [How does it work?](#how-does-it-work)\n* Why is this solution so complicated?\n\t* [Why can't I just create a new `require` variable?](#why-cant-i-just-create-a-new-require-variable)\n\t* [Why can't I just override `require()` in my app.js?](#why-cant-i-just-override-require-in-my-appjs)\n* [What are the caveats?](#what-are-the-caveats)\n\n### Why is this so cool?\n\nBecause now you can start leveraging the power of node.js and npm package management in your Alloy apps.\n\n```bash\n$ npm install --prefix ./app/lib ti-mocha should underscore\n```\n\n#### alloy.js\n```js\nvar should = require('should/should'), // require the broswer-compatible version in should\n\t_ = require('underscore');\nrequire('ti-mocha');\n\ndescribe('ti-commonjs', function() {\n\tit('should work', function() {\n\t\t_.each([1,2,3], function(num) {\n\t\t\tnum.should.equal(num);\n\t\t});\n\t});\n});\nmocha.run();\n```\n\n### Should I use `ti-commonjs.js`?\n\n#### cons\n\n* It will probably break your existing Titanium code. The primary reason for this is fundamental difference in specifying absolute paths with Titanium's `require()` vs. `ti-commonjs.js`. This example illustrates, assuming that a module exists at `Resources/foo/bar.js`:\n```js\n// This is how it's done with Titanium's require()\nrequire('foo/bar');\n\n// and this is how its done with ti-commonjs.js\nrequire('/foo/bar');\n```\n\n#### pros\n\n* This is the CommonJS implementation and `require()` usage that will be supported in Titanium 4.0 (Lovingly being referred to as [Ti.Next](http://www.appcelerator.com/blog/2013/09/updates-on-ti-next/)). You can start future-proofing your apps now.\n* You get all of the great features listed in the [Usage](#usage) section.\n* You can install and distribute modules via [npm](https://www.npmjs.org/)! no more digging through github or Q&A posts.\n* Eliminates all platform-specific disparities in Titanium's CommonJS implementation.\n* It becomes _much_ easier to port existing node.js modules to Titanium. Many you'll be able to use now without any modifications.\n* It is much easier for incoming node.js developers to start using Titanium with this more familiar CommonJS implementation.\n\n### How does it work?\n\n`ti-commonjs.js` overides the existing Titanium `require()` to have node.js-style functionality. It sits directly on top of Titanium's existing module implementation so all module caching is preserved, no wheels are re-invented. It does this by invoking the main `ti-commonjs` function with the current `__dirname` then returns a curried function as the new `require()`.\n\nTo truly make the usage seamless, though, your generated Javascript files need a CommonJS wrapper, much like is done in the underlying engine itself. The wrapper looks like this:\n\n**app.js**\n```js\n(function(_require,__dirname,__filename) {\n\tvar require = _require('ti-commonjs')(__dirname);\n\n\t// your code..\n\n})(require,'/','/app.js');\n```\n\n### Why can't I just create a new `require` variable?\n\nBecause you'd be conflicting with the `require` already in the scope of every module.\n\n```js\nvar require = require('ti-commonjs'); // CONFLICT with global require\n```\n\n### Why can't I just override `require()` in my app.js?\n\nI should just be able to take advantage of Titanium's scoping with respect to the app.js file and have `require()` overridden everywhere, right? Well, you're right, but that's where the problem lies. The issue is that `require()` needs to be executed relative to the current file's directory when it comes to relative paths. This is further compounded by properties like `require.paths`. Globally overriding `require()`, though, will make all paths relative to `Resources`. Let me demonstrate.\n\n**app.js**\n```js\nrequire = require('ti-commonjs');\nrequire('/1/2/3/threeModule')();\n```\n\n**1/2/3/threeModule.js**\n```js\nmodule.exports = function() {\n\t// DISASTER! You'd think you were referencing '/1/2/3/../twoModule' here,\n\t// but because the relative directory was established in the app.js\n\t// you are instead referencing '/../twoModule'. This will end in a\n\t// runtime error.\n\trequire('../twoModule')();\n};\n```\n\n**1/2/twoModule.js**\n```js\nmodule.exports = function() {\n\tconsole.log();\n};\n```\n\n### What are the caveats?\n\n* `module.parent` and `module.children` cannot be supported since the underlying Titanium `require()` provides no means to get them or assign them to a module. To be able to support this, a change would be required in Titanium. Fortunately, these are rarely used.\n* This implementation does not load modules with the `.node` extension, as those are for node.js compiled addon modules, which make no sense in the context of Titanium.\n* `ti-commonjs.js` does not load from global folders (i.e., `$HOME/.node_modules`), as they are not relevant to mobile app distributions.\n",
  "readmeFilename": "README.md",
  "_id": "ti-commonjs@0.0.1",
  "_from": "ti-commonjs@"
}
